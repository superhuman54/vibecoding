name: 🏷️ PR 자동 라벨링

on:
  pull_request:
    types: [opened, reopened, edited, synchronize]

jobs:
  auto-label:
    name: 자동 라벨 적용
    runs-on: ubuntu-latest
    
    steps:
    - name: 코드 체크아웃
      uses: actions/checkout@v4
      
    - name: PR 제목 기반 라벨링
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo } = context.repo;
          const prNumber = context.payload.pull_request.number;
          const title = context.payload.pull_request.title.toLowerCase();
          const body = context.payload.pull_request.body || '';
          
          const labelsToAdd = [];
          
          // 제목 기반 타입 라벨링
          if (title.includes('[feat]') || title.includes('feature') || title.includes('add')) {
            labelsToAdd.push('type/feature');
          } else if (title.includes('[fix]') || title.includes('bug') || title.includes('hotfix')) {
            labelsToAdd.push('type/bugfix');
          } else if (title.includes('[docs]') || title.includes('documentation')) {
            labelsToAdd.push('type/documentation');
          } else if (title.includes('[style]') || title.includes('[refactor]') || title.includes('improve')) {
            labelsToAdd.push('type/enhancement');
          } else if (title.includes('[test]') || title.includes('testing')) {
            labelsToAdd.push('type/test');
          } else if (title.includes('[chore]') || title.includes('maintenance')) {
            labelsToAdd.push('type/chore');
          }
          
          // 우선순위 라벨링
          if (title.includes('urgent') || title.includes('critical') || title.includes('hotfix')) {
            labelsToAdd.push('priority/high');
          } else if (title.includes('important') || title.includes('[fix]')) {
            labelsToAdd.push('priority/medium');
          } else {
            labelsToAdd.push('priority/low');
          }
          
          // 내용 기반 라벨링
          if (body.includes('breaking change') || body.includes('BREAKING CHANGE')) {
            labelsToAdd.push('breaking-change');
          }
          
          if (body.includes('wip') || body.includes('work in progress') || title.includes('wip')) {
            labelsToAdd.push('status/in-progress');
          } else {
            labelsToAdd.push('status/ready-for-review');
          }
          
          // 라벨 추가
          if (labelsToAdd.length > 0) {
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: prNumber,
              labels: labelsToAdd
            });
            
            console.log(`✅ 추가된 라벨: ${labelsToAdd.join(', ')}`);
          }

  file-based-labeling:
    name: 파일 기반 라벨링
    runs-on: ubuntu-latest
    
    steps:
    - name: 변경된 파일 기반 라벨링
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo } = context.repo;
          const prNumber = context.payload.pull_request.number;
          
          // PR의 변경된 파일들 가져오기
          const files = await github.rest.pulls.listFiles({
            owner,
            repo,
            pull_number: prNumber
          });
          
          const areaLabels = [];
          
          // 파일 경로 기반 영역 라벨링
          files.data.forEach(file => {
            const filePath = file.filename;
            
            if (filePath.startsWith('backend/')) {
              if (!areaLabels.includes('area/backend')) {
                areaLabels.push('area/backend');
              }
            }
            
            if (filePath.startsWith('frontend/')) {
              if (!areaLabels.includes('area/frontend')) {
                areaLabels.push('area/frontend');
              }
            }
            
            if (filePath.startsWith('docs/') || filePath.endsWith('.md')) {
              if (!areaLabels.includes('area/documentation')) {
                areaLabels.push('area/documentation');
              }
            }
            
            if (filePath.startsWith('tests/') || filePath.includes('test')) {
              if (!areaLabels.includes('area/testing')) {
                areaLabels.push('area/testing');
              }
            }
            
            if (filePath.startsWith('.github/')) {
              if (!areaLabels.includes('area/ci-cd')) {
                areaLabels.push('area/ci-cd');
              }
            }
            
            if (filePath.includes('requirements.txt') || filePath.includes('package.json')) {
              if (!areaLabels.includes('dependencies')) {
                areaLabels.push('dependencies');
              }
            }
          });
          
          // 영역 라벨 추가
          if (areaLabels.length > 0) {
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: prNumber,
              labels: areaLabels
            });
            
            console.log(`✅ 영역 라벨 추가: ${areaLabels.join(', ')}`);
          }

  security-labeling:
    name: 보안 관련 라벨링
    runs-on: ubuntu-latest
    
    steps:
    - name: 보안 관련 파일 확인
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo } = context.repo;
          const prNumber = context.payload.pull_request.number;
          const title = context.payload.pull_request.title.toLowerCase();
          const body = context.payload.pull_request.body || '';
          
          const securityKeywords = [
            'security', 'vulnerability', 'auth', 'password', 'token', 'secret',
            'encryption', 'ssl', 'tls', 'cors', 'xss', 'sql injection', 'csrf'
          ];
          
          const hasSecurityContent = securityKeywords.some(keyword => 
            title.includes(keyword) || body.toLowerCase().includes(keyword)
          );
          
          // 변경된 파일에서 보안 관련 파일 확인
          const files = await github.rest.pulls.listFiles({
            owner,
            repo,
            pull_number: prNumber
          });
          
          const securityFiles = [
            'config.py', 'settings.py', '.env', 'requirements.txt',
            'auth', 'security', 'middleware'
          ];
          
          const hasSecurityFiles = files.data.some(file => 
            securityFiles.some(secFile => file.filename.includes(secFile))
          );
          
          if (hasSecurityContent || hasSecurityFiles) {
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: prNumber,
              labels: ['security']
            });
            
            console.log('✅ 보안 라벨 추가됨');
            
            // 보안 검토 요청 댓글
            const comment = `## 🔒 보안 검토 필요

            이 PR은 보안과 관련된 변경사항을 포함하고 있습니다.
            
            **보안 체크리스트:**
            - [ ] 민감한 정보가 하드코딩되지 않았는가?
            - [ ] 인증/인가 로직이 올바르게 구현되었는가?
            - [ ] 입력 검증이 적절히 수행되는가?
            - [ ] 보안 헤더가 설정되었는가?
            - [ ] 의존성 보안 취약점이 없는가?
            
            **추가 검토가 필요한 경우 보안 전문가에게 문의하세요.**
            
            ---
            _자동으로 감지된 보안 관련 변경사항입니다._`;
            
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: comment
            });
          } 